[
  {
    "id": "58e209dd-99b2-4ab7-9efa-ebd13365d6aa",
    "title": "[M-03] MultiStrategy#removeStrategy() cannot remove leverage strategies that still have deployed assets",
    "description": "A deployed leveraged strategy can become permanently stuck in a MultiStrategyVault because the vault’s remove flow requires the strategy to return invested funds but the vault lacks free liquidity to accept them. End-to-end: governance/operator calls MultiStrategyVault.removeStrategy(strategy) (or similar public remover); the vault attempts to call the strategy’s exit/withdraw method (e.g. Strategy.exit(), Strategy.withdrawAll(), Strategy.redeem() or Strategy.deleverage()) or to transfer the strategy’s share into vault reserves. The vault logic inspects state like MultiStrategyVault.totalAssets, MultiStrategyVault.availableLiquidity (or vaultBalance) and strategy-specific fields such as strategyInfo[strategy].deployedAssets, strategyAllocations, strategies[], and strategyDebt/allocatedAssets; if availableLiquidity < strategyInfo[strategy].deployedAssets the withdraw/redeem call can revert or fail and the strategy remains registered with allocations/debt unchanged. An attacker or adverse condition (locking funds in the external protocol or draining vault liquidity) can trigger this, blocking strategy removal, reallocation, emergency upgrades, or withdrawals. Fixes include supporting forced governance removal, maintaining a reserve to cover removals, or guaranteeing a reliable strategy.exit()/deleverage() path that can unwind positions even when vault liquidity is low.",
    "severity": "medium",
    "contract_name": "MultiStrategyVault",
    "project_name": "2024-12-bakerfi",
    "unique_key": "2024-12-bakerfi-M-03"
  },
  {
    "id": "70a00699-6d3e-4742-a439-40d396b118ad",
    "title": "[M-04] Not verifying that transaction initiator is the actual participator allows malicious user to allocate full reward as Uniswap V2 pool",
    "description": "To participate in campaign, user has to call swap provider (Li.Fi) Executor::swapAndExecute function. This function performs swap required to get campaign target tokens and calls NudgeCampaign::handleReallocation. NudgeCampaign will receive and forward target tokens to userAddress and update user participation details accordingly. handleReallocation is only callable by SWAP_CALLER_ROLE which is given to Executor to make sure user swaps tokens before being able to participate.",
    "severity": "medium",
    "contract_name": "NudgeCampaign",
    "project_name": "2025-03-nudgexyz",
    "unique_key": "2025-03-nudgexyz-M-04"
  },
  {
    "id": "0841fdc8-6598-4351-a9dc-c54bd29019fd",
    "title": "[M-03] All reallocate cross-chain token and rewards will be lost for the users using the account abstraction wallet",
    "description": "Users with account abstraction wallets have a different address across different chains for same account, so if user using an account abstraction wallet initiate reallocate cross-chain token, the toToken will be sent to wrong address and lost permanently. ",
    "severity": "medium",
    "contract_name": "NudgeCampaign",
    "project_name": "2025-03-nudgexyz",
    "unique_key": "2025-03-nudgexyz-M-03"
  },
  {
    "id": "48a04e71-1cf1-4fd2-9182-f678ef254a8b",
    "title": "[M-01] User can earn rewards by frontrunning the new rewards accumulation in Ron staking without actually delegating his tokens",
    "description": "The Ron staking contract let us earn rewards by delegating our tokens to a validator. But you will only earn rewards on the lowest balance of the day (source). So if you delegate your tokens on the first day, you are going to earn 0 rewards for that day as your lowest balance was 0 on that day. This will happens with every new delegator.",
    "severity": "medium",
    "contract_name": "LiquidRon",
    "project_name": "2025-01-liquid-ron",
    "unique_key": "2025-01-liquid-ron-M-01"
  },
  {
    "id": "448c98b6-cc2b-4fff-9a65-1b1329daa109",
    "title": "[M-10] The withdrawal of Multi strategies vault could be DoSed while asset deposits remain unaffected",
    "description": "Issue: MultiStrategyVault._undeploy(amount) calls MultiStrategy._deallocateAssets(amount). _deallocateAssets iterates the _strategies array, reads each strategy.totalAssets() into local currentAssets[i], sums totalAssets, computes fractAmount = (amount * currentAssets[i]) / totalAssets and then calls IStrategy(_strategies[i]).undeploy(fractAmount). Root cause: when currentAssets[i] == 0 this yields fractAmount == 0 but the code still calls undeploy(0). Several real strategies (e.g. StrategySupplyBase.undeploy(uint256) which reverts ZeroAmount(), and StrategyLeverage.undeploy(...) which reverts NoCollateralMarginToScale() when balances are zero) revert on undeploy(0). Exploit/impact: an attacker or misconfigured admin can add/register a strategy in _strategies that reports totalAssets() == 0 or otherwise has zero deployed assets but reverts on undeploy(0). That causes _deallocateAssets to revert and DoS the withdrawal flow (vault.withdraw -> MultiStrategyVault._undeploy -> _deallocateAssets), blocking withdrawals. Fixes: skip calling undeploy when fractAmount == 0 or skip strategies with currentAssets[i] == 0; handle totalAssets == 0 as a special case; or require/standardize strategy implementations to accept undeploy(0) as a no-op and/or validate/reject strategies on addStrategy.",
    "severity": "medium",
    "contract_name": "MultiStrategy",
    "project_name": "2024-12-bakerfi",
    "unique_key": "2024-12-bakerfi-M-10"
  },
  {
    "id": "e501a1cf-4133-4994-8b34-0baa398d2bfd",
    "title": "[M-15] VaultRouter cannot be used for deposits when it reaches the maximum deposit limit",
    "description": "VaultRouter forwards user deposits to Vault by calling Vault.deposit(amount) so msg.sender inside Vault is VaultRouter. Vault enforces a per-depositor cap using the state mapping deposits[msg.sender] and the uint maxDeposit, updating deposits[VaultRouter] and checking deposits[VaultRouter] <= maxDeposit on each deposit. End-to-end this means multiple users routing through VaultRouter all increment deposits[VaultRouter] until it hits maxDeposit, after which further Vault.deposit calls revert and VaultRouter can no longer deposit on behalf of users even though those users individually have not reached their own limits, causing a denial-of-service for routed deposits.",
    "severity": "medium",
    "contract_name": "VaultRouter",
    "project_name": "2024-12-bakerfi",
    "unique_key": "2024-12-bakerfi-M-15"
  },
  {
    "id": "8bebc388-7eba-4310-9815-d9a158f0646b",
    "title": "[M-13] The Vault Manager is unable to delete the last strategy from MultiStrategyVault",
    "description": "In the VaultManager contract the VAULT_MANAGER_ROLE cannot remove the final strategy because the removal functions (e.g. removeStrategy(address _strategy) / revokeStrategy(...)) include a guard like require(strategies.length > 1) that prevents removal when only one strategy remains. The deletion path updates state variables address[] public strategies, mapping(address => bool) public isStrategy and a strategy count (e.g. uint256 strategyCount) but never allows the last entry to be removed: when strategies.length == 1 the require check reverts, so the function never reaches the code that clears isStrategy[_strategy], removes from the strategies array or decrements strategyCount. As a result, if the system is reduced to a single strategy (by normal operations or misconfiguration), a manager holding VAULT_MANAGER_ROLE cannot delete or replace that final strategy, leaving funds and vault behavior permanently tied to that strategy and preventing emergency migration or remediation.",
    "severity": "medium",
    "contract_name": "MultiStrategyVault",
    "project_name": "2024-12-bakerfi",
    "unique_key": "2024-12-bakerfi-M-13"
  },
  {
    "id": "aaade98d-4321-476d-8338-5029236386f8",
    "title": "[H-02] Anyone can call StrategySupplyBase.harvest, allowing users to avoid paying performance fees on interest",
    "description": "Issue: StrategySupplyBase.harvest (external) updates state variable _deployedAmount by computing balanceChange = int256(newBalance) - int256(_deployedAmount) and then setting _deployedAmount = newBalance. The vault fee flow calls _harvestAndMintFees -> _harvest -> _strategy.harvest() to obtain balanceChange and then mints protocol fees via _mint(feeReceiver, sharesToMint) where feeReceiver = getFeeReceiver(), performanceFee = getPerformanceFee(), currentPosition = _totalAssets(), feeInEth = uint256(balanceChange) * performanceFee and sharesToMint = feeInEth.mulDivUp(totalSupply(), currentPosition * PERCENTAGE_PRECISION). Vulnerability (end-to-end): because StrategySupplyBase.harvest is public/external, an attacker can call StrategySupplyBase.harvest to set _deployedAmount to newBalance before the administrator triggers vault.rebalance (which calls _harvestAndMintFees). When the admin later calls _harvestAndMintFees -> _harvest -> _strategy.harvest(), the strategy returns balanceChange == 0, so feeInEth == 0 and sharesToMint == 0 and no performance fees are minted. Impact: attackers can front-run or pre-call harvest to prevent protocol performance fee minting and capture excess interest. Exploit path: attacker calls StrategySupplyBase.harvest (updates _deployedAmount -> newBalance) -> admin calls vault.rebalance -> _harvestAndMintFees -> _harvest -> _strategy.harvest() returns 0 -> fee minting skipped. Mitigations: restrict StrategySupplyBase.harvest to vault/keeper/admin, make the state update internal or require authentication, decouple fee accounting from _deployedAmount by tracking a separate feeCheckpoint, or have the vault compute profit via a non-state-changing view and mint fees before the strategy updates _deployedAmount.",
    "severity": "high",
    "contract_name": "StrategySupplyBase",
    "project_name": "2024-12-bakerfi",
    "unique_key": "2024-12-bakerfi-H-02"
  },
  {
    "id": "dc7a4e05-f737-4411-915f-6ee408eda2a8",
    "title": "[H-04] There are multiple issues with the decimal conversions between the vault and the strategy",
    "description": "Root cause: StrategyLeverage assumes 18 decimals everywhere and uses fixed 1e18 scaling in its conversion helpers instead of reading ERC20.decimals(), breaking support for tokens with decimals != 18. Internal helpers named _to18(), _from18(), convertTo18(), convertFrom18() (or similarly named) are applied to the protocol token stored in state variable want/token and to local variables like amount18, scaledAmount, wantAmount. Those conversions feed public functions deposit(), withdraw(), leverage(), _rebalance(), and harvest(), causing incorrect updates to share and position accounting state variables totalSupply/shares/balances (share accounting) and debt/reserveIn18/leverageFactor (position/debt accounting). End-to-end exploit: an attacker supplies a non-18-decimal token (e.g. 6 or 8 decimals) to deposit(); deposit() calls the hard-coded _to18()/convertTo18() and mints over- or under-valued shares and records wrong debt/reserveIn18; the attacker then calls withdraw(), which uses _from18()/convertFrom18() with the same wrong scale to withdraw more underlying than entitled, or manipulates leverage()/_rebalance() to create mismatched debt and drain funds. In short, fixed 1e18 normalization across conversion helpers, deposit/withdraw/leverage paths, and share/debt state enables incorrect accounting and potential theft when interacting with non-18-decimal tokens.",
    "severity": "high",
    "contract_name": "StrategyLeverage",
    "project_name": "2024-12-bakerfi",
    "unique_key": "2024-12-bakerfi-H-04"
  }
]
